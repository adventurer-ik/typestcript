3.0
call signature
:typescript에게 함수를 어떻게 호출하는지, 또 함수의 반환 타입도 알려줌
:인자(arguments)의 타입, 함수의 반환 타입 제공

type Add = (a:number, b:number) => number;
이렇게 call signature 지정해주면 됨.

const add:Add = (a, b) => a + b
그리고 이렇게 함수 만들고,. 함수 위에 마우스 over 하면 알 수 있음!

3.1
오버로딩 overloading
함수가 여러개의 call signatures를 가지고 있을 때 발생 됨
어렵게 생각하지말자.
다시 말하자면, 오버로딩은
여러 call signatures가 있는 함수 일뿐..!!

일상 개발에서 볼 수 있는 오버로딩

type Config = {
    path: string,
    state: object
}

type Push = {
    (path: string): void
    (config: Config): void
}

const push:Push = (config) => {
    if (typeof config === "string") { console.log(config) }
    else {
        console.log(config.path)
    }
}

call signatures에서, type만 다른 것도 있지만,
파라미터의 개수가 다른 경우도 있음
type Add2 = {
    (a:number, b:number): number
    (a:number, b:number, c:number): number
}

# 3.3
type SuperPrint = <T>(a: T[]) => T

const superPrint: SuperPrint = (a) => a[0]

const a = superPrint([1, 2, 3, 4])
const b = superPrint([true, false, true])
const c = superPrint(["a", "b", "c"])
const d = superPrint([1, 2, true, "hello"])

<T> 를 활용했다는 것은 타입스크립트에게 우리는 T라는 제네릭을 쓴다라고 알려준 것임.
T는 배열에서 오고, 함수의 첫번째 파라미터에서 오는 거라고 ts에게 알려준 것임.
const a 해석 ->
TS는 이걸 기반 (a: T[])으로 여기를 살펴봐야 하는 것을 알고,  배열의 첫 값 1을 보고
number임을 인식, T를 number로 바꿔줌.

기억하자.
제네릭은 내가 요구한 대로 signature를 생성해줄 수 있는 도구라고 생각하면 된다.


# 3.4 - Conclusions
우리가 실제 코드 작성할 때는 type 을 통해 제네릭을 사용하여 작성해서 call signature를 만드는 경우는 거의 없음.
주로 라이브러리 등을 만들 때 사용하는 편임.
우리는 쓴다면 함수를 만들 때 같이 제네릭 선언해주면서 쓰는 편임.

function superPrint<T>(a: T[]) {
    return a[0]
}

이렇게 해주면 된다!
그리고 해당 함수를 호출할때 type을 선언 해줄 수 있지만 왠만하면 typescript가 유추하도록 하자.

제네릭은 재 사용이 가능함.

인터넷에서 검색하면 나오는 설명 중 하나.
'제네릭은 선언 시점이 아니라 생성 시점에 타입을 명시하여 하나의 타입만이 아닌 다양한 타입을 사용할 수 있도록 하는 기법이다.'

# 4.1 Classes
abstract class (추상 클래스)
추상 메소드를 만들려면, 메소드를 클래스 안에서 구현(implementation)하지 않으면 된다.
추상 클래스 안에서는 추상 메소드를 만들 수 있다.
하지만, 메소드를 구현해서는 안 되고, 대에 메소드의 call signature만 적어두어야 한다.
메소드는 클래스 안에 존재하는 함수이다.

//추상 클래스 생성
abstract class User {
    constructor(
        // typescript에는 private 존재 -> js는 없음.
        // ts -> js로 컴파일하면서 사라짐. ts가 개발자 보호해주는 용도임. 여기선...
        protected firstName: string,
        protected lastName: string,
        protected nickName: string
    ) {}

    abstract getNickName(): void

    getFullName() {
        return `${this.firstName} ${this.lastName}`
    }
}

class Player extends User {
    // 추상 클래스에 추상 메소드가 있다면, 해당 추상 클래스를 상속받는 녀석은 반드시 구현해야 함.
    getNickName() {
        console.log(this.nickName)
    }
}

const ik = new Player("JeongIK", "Seo", "또르");


 public, private, protected
 여기서 protected는 클래스 밖에서는 private처럼 접근이 불가능 하나,
 자식 클래스가 상속 받는 상황에서는 접근이 가능하다.


# 4.2 Recap
1. # 4.1 복습
 - public, protected, private
 - abstract class, abstract method
 - 관련 보호기능은 js는 신경안씀. 오직 ts에서만 보호해줌.

# 4.2 Interfaces
- pulbic의 경우 수정이 가능하다.
  다만, public을 유지하되, 수정은 불가능하게 할 수 있다.
  바로 readonly를 추가해주는 것이다.
  ex) public readonly term: string

- static
 : ts 것이 아니라 js 것이다.

- interface
 : 오직 한 가지 용도만을 가지고 있다.
   → 오브젝트의 모양을 특정해주기 위한 것임.
   → React.js를 이용해 작업을 할 때 많이 사용함.
   → js로 컴파일시 번역(?)되지 않음 - 파일 사이즈가 작아짐!
   → 단순히 객체의 형태를 알려주는 용도라면 interface가 좋다.
   → abstract 같은거는 extends 키워드 써서 상속하지만, interface는 implementation 을 써서 상속해야 한다.

- ts에 object 모양을 알려주는 방법은 2가지가 있음
 : type, interface
 
 type Team = "red" | "blue" | "yellow"
 type Health = 1 | 5 | 10
 type Player1 = {
    nickname: string,
    team: Team,
    health: Health
 }
 interface Player2 {
    nickname: string,
    team: Team,
    health: Health
 }
위 코드를 보면 type과 interface의 차이가 보이는가?

type 키워드와 interface 키워드 간의 다른 점은, type 키워드가 활용도가 더 높다는 것임.
interface는 오직 object 모양을 typescript에 설명해주는 용도로만 쓰이는 키워드이기 때문이다.
object 형태를 만들 때는 interface가 보기 더 좋은듯 하다.
취향 차이긴 하지만 나는 interface를 쓰는 것이 더 잘 맞는듯 하다.

※ 타입스크립트 커뮤니티
: 클래스나 오브젝트의 모양을 정의하고 싶으면 interface 키워드 쓰고
: 그외 다른 모든 경우에서는 type 키워드를 쓰는 것을 권장함.


# 4.5 Polymorphism
Polymorphism (다형성) - 다른 모양의 코드를 가질 수 있게 해주는 것
다형성을 이루는 방법은 제네릭을 부여하는 것임.
제네릭은 placeholder 타입을 쓸 수 있도록 해주는 것임.
 - concreate 타입이 아니라 placeholder 타입!!
 - 적절한 때가 되면 typescript가 placeholder 타입을 concreate타입으로 바꿔줄 거임.
   : 그러므로 우리는 신경쓸 필요없이 placeholder루 가면 됨!
   
