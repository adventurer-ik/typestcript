3.0
call signature
:typescript에게 함수를 어떻게 호출하는지, 또 함수의 반환 타입도 알려줌
:인자(arguments)의 타입, 함수의 반환 타입 제공

type Add = (a:number, b:number) => number;
이렇게 call signature 지정해주면 됨.

const add:Add = (a, b) => a + b
그리고 이렇게 함수 만들고,. 함수 위에 마우스 over 하면 알 수 있음!

3.1
오버로딩 overloading
함수가 여러개의 call signatures를 가지고 있을 때 발생 됨
어렵게 생각하지말자.
다시 말하자면, 오버로딩은
여러 call signatures가 있는 함수 일뿐..!!

일상 개발에서 볼 수 있는 오버로딩

type Config = {
    path: string,
    state: object
}

type Push = {
    (path: string): void
    (config: Config): void
}

const push:Push = (config) => {
    if (typeof config === "string") { console.log(config) }
    else {
        console.log(config.path)
    }
}

call signatures에서, type만 다른 것도 있지만,
파라미터의 개수가 다른 경우도 있음
type Add2 = {
    (a:number, b:number): number
    (a:number, b:number, c:number): number
}

# 3.3
type SuperPrint = <T>(a: T[]) => T

const superPrint: SuperPrint = (a) => a[0]

const a = superPrint([1, 2, 3, 4])
const b = superPrint([true, false, true])
const c = superPrint(["a", "b", "c"])
const d = superPrint([1, 2, true, "hello"])

<T> 를 활용했다는 것은 타입스크립트에게 우리는 T라는 제네릭을 쓴다라고 알려준 것임.
T는 배열에서 오고, 함수의 첫번째 파라미터에서 오는 거라고 ts에게 알려준 것임.
const a 해석 ->
TS는 이걸 기반 (a: T[])으로 여기를 살펴봐야 하는 것을 알고,  배열의 첫 값 1을 보고
number임을 인식, T를 number로 바꿔줌.

기억하자.
제네릭은 내가 요구한 대로 signature를 생성해줄 수 있는 도구라고 생각하면 된다.


# 3.4 - Conclusions
우리가 실제 코드 작성할 때는 type 을 통해 제네릭을 사용하여 작성해서 call signature를 만드는 경우는 거의 없음.
주로 라이브러리 등을 만들 때 사용하는 편임.
우리는 쓴다면 함수를 만들 때 같이 제네릭 선언해주면서 쓰는 편임.

function superPrint<T>(a: T[]) {
    return a[0]
}

이렇게 해주면 된다!
그리고 해당 함수를 호출할때 type을 선언 해줄 수 있지만 왠만하면 typescript가 유추하도록 하자.

제네릭은 재 사용이 가능함.

인터넷에서 검색하면 나오는 설명 중 하나.
'제네릭은 선언 시점이 아니라 생성 시점에 타입을 명시하여 하나의 타입만이 아닌 다양한 타입을 사용할 수 있도록 하는 기법이다.'